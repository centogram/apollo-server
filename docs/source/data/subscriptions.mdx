---
title: Subscriptions
description: Persistent GraphQL operations
---

import {ExpansionPanel} from 'gatsby-theme-apollo-docs';

> **Subscriptions are not supported in [Apollo Federation](https://www.apollographql.com/docs/federation/).**

**Subscriptions** are GraphQL operations that maintain an active connection between client and server. This enables your server to _push_ updates to a subscription's result as they occur, instead of requiring your client to _poll_ for updates.

Because subscriptions use persistent two-way communication, they usually use [the WebSocket protocol](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) instead of HTTP. To help support this, Apollo Server lets you create a subscription-specific endpoint that's separate from the default endpoint for queries and mutations.

> **Important:** Compared to queries and mutations, subscriptions are significantly more complex to implement correctly. Before you begin, [confirm that your use case requires subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/#when-to-use-subscriptions).

## Schema definition

You define your schema's supported subscriptions as fields of the `Subscription` type:

```graphql
type Subscription {
  postCreated: Post
}
```

The `postCreated` subscription will update its value whenever a post is created on the backend, thus pushing the new post to subscribing clients.

Clients can execute this subscription with a GraphQL string like this:

```graphql
subscription PostFeed {
  postCreated {
    author
    comment
  }
}
```

## Resolving a subscription

Because subscriptions are continuous instead of transactional, their resolvers differ from those of queries and mutations. Specifically, subscription resolvers are _objects_ that define a `subscribe` function:

```js:title=index.js
const resolvers = {
  Subscription: {
    postCreated: {
      // More on pubsub below
      subscribe: () => pubsub.asyncIterator(['POST_CREATED']),
    },
  },
  // ...other resolvers...
};
```

The `subscribe` function must return an object of type `AsyncIterable`, part of Apollo Server's pub/sub API (described below).

### The `PubSub` class (development only)

> The `PubSub` class is **not** recommended for production environments. After you get subscriptions working in development, we strongly recommend switching it out for a different subclass of the abstract [`PubSubEngine` class](https://github.com/apollographql/graphql-subscriptions/blob/master/src/pubsub-engine.ts). Recommended subclasses are listed in [PubSub implementations](#pubsub-implementations).

Apollo Server uses a **publish-subscribe** (**pub/sub**) model to track events that update active subscriptions. The [`graphql-subscriptions` library](https://github.com/apollographql/graphql-subscriptions) (included in every `apollo-server` package) provides the `PubSub` class to help you get started:

```js
const { PubSub } = require('apollo-server');

const pubsub = new PubSub();
```

A `PubSub` instance enables your server code to both `publish` events to a particular label and listen for events associated with a particular label.

### Publishing an event

You publish an event with the `publish` method of a `PubSub` instance:

```js
pubsub.publish('POST_CREATED', {
  postCreated: {
    author: 'Ali Baba',
    comment: 'Open sesame'
  }
});
```

* The first parameter is the name of the event label you're publishing to, as a string.
    * _You don't need to register a label name before publishing to it._
* The second parameter is the payload associated with the event.
    * _This should match the structure of the associated subscription's return type._

When working with GraphQL subscriptions, you should `publish` an event whenever a subscription's return value changes. One of the most common causes of such a change is a mutation.

For example, let's say our GraphQL API supports a `createPost` mutation:

```graphql
type Mutation {
  createPost(author: String, comment: String): Post
}
```

A basic resolver for `createPost` might look like this:

```js{3-6}
const resolvers = {
  Mutation: {
    createPost(parent, args, context) {
      // Datastore logic lives in postController
      return postController.createPost(args);
    },
  },
  // ...other resolvers...
};
```

Before we persist the new post's details in our datastore, we can `publish` an event that _also_ includes those details:

```js
const resolvers = {
  Mutation: {
    createPost(parent, args, context) {
      pubsub.publish('POST_CREATED', { postCreated: args }); // highlight-line
      return postController.createPost(args);
    },
  },
  // ...other resolvers...
};
```

Next, we can listen for this event in our subscription's resolver.

### Listening for events

An [`AsyncIterable`](https://github.com/apollographql/graphql-subscriptions/blob/master/src/pubsub-async-iterator.ts) object listens for events that are associated with a particular label (or set of labels) and adds them to a queue for processing. You create an `AsyncIterable` by calling the `asyncIterator` method of `PubSub`:

```js
pubsub.asyncIterator(['POST_CREATED']);
```

You pass this method an array containing the names of all event labels that the `AsyncIterable` should listen for.

Every subscription resolver's `subscribe` function must return an `AsyncIterable` object. This brings us back to the code sample at the top of [Resolving a subscription](#resolving-a-subscription):

```js:title=index.js
const resolvers = {
  Subscription: {
    postCreated: {
      subscribe: () => pubsub.asyncIterator(['POST_CREATED']),
    },
  },
  // ...other resolvers...
};
```

With this `subscribe` function set, Apollo Server uses the payloads of `POST_CREATED` events to push updated field values for the `postCreated` subscription.

### Combined example

This example combines the snippets from the sections above:

<ExpansionPanel title="Click to expand">

```js:title=index.js
const typeDefs = gql`
  type Subscription {
    postCreated: Post
  }

  type Query {
    posts: [Post]
  }

  type Mutation {
    createPost(author: String, comment: String): Post
  }

  type Post {
    author: String
    comment: String
  }
`

const resolvers = {
  Subscription: {
    postCreated: {
      subscribe: () => pubsub.asyncIterator(['POST_CREATED']),
    },
  },
  Query: {
    posts(parent, args, context) {
      return postController.posts();
    },
  },
  Mutation: {
    addPost(parent, args, context) {
      pubsub.publish('POST_CREATED', { postCreated: args });
      return postController.addPost(args);
    },
  },
};
```

</ExpansionPanel>

## Context with Subscriptions

The function to create a context for subscriptions includes `connection`, while the function for Queries and Mutations contains the arguments for the integration, in express's case `req` and `res`. This means that the context creation function needs to check the input. This is especially important, since the auth tokens are handled differently depending on the transport:

```js
const server = new ApolloServer({
  schema,
  context: async ({ req, connection }) => {
    if (connection) {
      // check connection for metadata
      return connection.context;
    } else {
      // check from req
      const token = req.headers.authorization || "";

      return { token };
    }
  },
});
```

> `connection` contains various metadata, found [here](https://github.com/apollographql/subscriptions-transport-ws/blob/88970eaf6d2e3f68f98696de00631acf4062c088/src/server.ts#L312-L321).

As you can see Apollo Server 2.0 allows realtime data without invasive changes to existing code.
For a full working example please have a look to [this repo](https://github.com/daniele-zurico/apollo2-subscriptions-how-to) provided by [Daniele Zurico](https://github.com/daniele-zurico/apollo2-subscriptions-how-to)

## Authentication Over WebSocket

To support an authenticated transport, Apollo Server provides lifecycle hooks, including `onConnect` to validate the connection.

On the client, `SubscriptionsClient` supports adding token information to `connectionParams` ([example](https://www.apollographql.com/docs/react/advanced/subscriptions/#authentication-over-websocket)) that will be sent with the first WebSocket message. In the server, all GraphQL subscriptions are delayed until the connection has been fully authenticated and the `onConnect` callback returns a truthy value.

The `connectionParams` argument in the `onConnect` callback contains the information passed by the client and can be used to validate user credentials.
The GraphQL context can also be extended with the authenticated user data to enable fine grain authorization.

```js
const { ApolloServer } = require('apollo-server');
const { resolvers, typeDefs } = require('./schema');

const validateToken = authToken => {
  // ... validate token and return a Promise, rejects in case of an error
};

const findUser = authToken => {
  return tokenValidationResult => {
    // ... finds user by auth token and return a Promise, rejects in case of an error
  };
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
  subscriptions: {
    onConnect: (connectionParams, webSocket) => {
      if (connectionParams.authToken) {
        return validateToken(connectionParams.authToken)
          .then(findUser(connectionParams.authToken))
          .then(user => {
            return {
              currentUser: user,
            };
          });
      }

      throw new Error('Missing auth token!');
    },
  },
});

server.listen().then(({ url, subscriptionsUrl }) => {
  console.log(`🚀 Server ready at ${url}`);
  console.log(`🚀 Subscriptions ready at ${subscriptionsUrl}`);
});
```

The example above validates the user's token that is sent with the first initialization message on the transport, then it looks up the user and returns the user object as a Promise. The user object found will be available as `context.currentUser` in your GraphQL resolvers.

In case of an authentication error, the Promise will be rejected, which prevents the client's connection.

## Subscription Filters

Sometimes a client will want to filter out specific events based on context and arguments.

To do so, we can use the `withFilter` helper from the `apollo-server` or `apollo-server-{integration}` package to control each publication for each user. Inside of `withFilter`,  the `AsyncIterator` created by `PubSub` is wrapped with a filter function.

Let's see an example - for the `commentAdded` server-side subscription, the client want to subscribe only to comments added to a specific repo:

```
subscription($repoName: String!){
  commentAdded(repoFullName: $repoName) {
    id
    content
  }
}
```

When using `withFilter`, provide a filter function. The filter is executed with the payload (a published value), variables, context and operation info. This function must return a `boolean` or `Promise<boolean>` indicating if the payload should be passed to the subscriber.

The following definition of the subscription resolver will filter out all of the `commentAdded` events that are not associated with the requested repository:

```js{8,10-12}
const { withFilter } = require('apollo-server');

const resolvers = {
    Query: () => { ... },
    Mutation: () => { ... },
    Subscription: {
        commentAdded: {
          subscribe: withFilter(
            () => pubsub.asyncIterator('COMMENT_ADDED'),
            (payload, variables) => {
             return payload.commentAdded.repository_name === variables.repoFullName;
            },
          ),
        }
    },
};
```

## Subscriptions with Additional Middleware

With an existing HTTP server (created with `createServer`), we can add subscriptions using the `installSubscriptionHandlers`. Additionally, the subscription-capable integrations export `PubSub` and other subscription functionality.

For example: with an Express server already running on port 4000 that accepts GraphQL HTTP connections (POST) we can expose the subscriptions:

```js
const http = require('http');
const { ApolloServer } = require('apollo-server-express');
const express = require('express');

const PORT = 4000;
const app = express();
const server = new ApolloServer({ typeDefs, resolvers });

server.applyMiddleware({app})

const httpServer = http.createServer(app);
server.installSubscriptionHandlers(httpServer); // highlight-line

// ⚠️ Pay attention to the fact that we are calling `listen` on the http server variable, and not on `app`.
httpServer.listen(PORT, () => {
  console.log(`🚀 Server ready at http://localhost:${PORT}${server.graphqlPath}`)
  console.log(`🚀 Subscriptions ready at ws://localhost:${PORT}${server.subscriptionsPath}`)
})
```

## Lifecycle Events

`ApolloServer` exposes lifecycle hooks you can use to manage subscriptions and clients:

* `onConnect` - called upon client connection, with the `connectionParams` passed to `SubscriptionsClient` - you can return a Promise and reject the connection by throwing an exception. The resolved return value will be appended to the GraphQL `context` of your subscriptions.
* `onDisconnect` - called when the client disconnects.

```js
const server = new ApolloServer(
  subscriptions: {
    onConnect: (connectionParams, webSocket, context) => {
      // ...
    },
    onDisconnect: (webSocket, context) => {
      // ...
    },
  },
);
```

## `PubSub` implementations

> **Please note**: By default `graphql-subscriptions` exports an in-memory (`EventEmitter`) event system to re-run subscriptions. This is not suitable for running in a serious production app, because there is no way to share subscriptions and publishes across many running servers.
>
> We recommend using one of the external `PubSub` implementations listed below for production environments.

The Apollo Server implementation of `PubSub` can be replaced by another implementations of [PubSubEngine interface](https://github.com/apollographql/graphql-subscriptions/blob/master/src/pubsub-engine.ts). The community has created the following integrations:

- [Redis](https://github.com/davidyaha/graphql-redis-subscriptions)
- [Google PubSub](https://github.com/axelspringer/graphql-google-pubsub)
- [MQTT enabled broker](https://github.com/davidyaha/graphql-mqtt-subscriptions)
- [RabbitMQ](https://github.com/cdmbase/graphql-rabbitmq-subscriptions)
- [Kafka](https://github.com/ancashoria/graphql-kafka-subscriptions)
- [Postgres](https://github.com/GraphQLCollege/graphql-postgres-subscriptions)
- [Google Cloud Firestore](https://github.com/MrBoolean/graphql-firestore-subscriptions)
- [Add your implementation...](https://github.com/apollographql/apollo-server/pull/new/main)

You can implement a `PubSub` of your own, using the exported `PubSubEngine` interface from `apollo-server` or another integration. If you want to set up a GraphQL server using the `graphql-subscriptions` package (not recommended for production), follow [this guide](https://www.apollographql.com/docs/graphql-subscriptions/).
