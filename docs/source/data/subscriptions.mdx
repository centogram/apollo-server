---
title: Subscriptions
description: Persistent GraphQL operations
---

import {ExpansionPanel} from 'gatsby-theme-apollo-docs';

> **Subscriptions are not supported in [Apollo Federation](https://www.apollographql.com/docs/federation/).**

**Subscriptions** are GraphQL operations that maintain an active connection between client and server. This enables your server to _push_ updates to a subscription's result as they occur, instead of requiring your client to _poll_ for updates.

Because subscriptions use persistent two-way communication, they usually use [the WebSocket protocol](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) instead of HTTP. To support this, Apollo Server lets you create a subscription-specific endpoint that's separate from the default endpoint for queries and mutations.

> **Important:** Compared to queries and mutations, subscriptions are significantly more complex to implement. Before you begin, [confirm that your use case requires subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/#when-to-use-subscriptions).

## Schema definition

You define your schema's supported subscriptions as fields of the `Subscription` type:

```graphql
type Subscription {
  postCreated: Post
}
```

The `postCreated` subscription will update its value whenever a new `Post` is created on the backend, thus pushing the `Post` to subscribing clients.

Clients can execute this subscription with a GraphQL string like this:

```graphql
subscription PostFeed {
  postCreated {
    author
    comment
  }
}
```

## Resolving a subscription

Because subscriptions are continuous instead of transactional, their resolvers differ from those of queries and mutations. Specifically, subscription resolvers are _objects_ that define a `subscribe` function:

```js:title=index.js
const resolvers = {
  Subscription: {
    postCreated: {
      // More on pubsub below
      subscribe: () => pubsub.asyncIterator(['POST_CREATED']),
    },
  },
  // ...other resolvers...
};
```

The `subscribe` function must return an object of type `AsyncIterable`, part of Apollo Server's pub/sub API (described below).

### The `PubSub` class

> The `PubSub` class is **not** recommended for production environments. After you get subscriptions working in development, we strongly recommend switching it out for a different subclass of the abstract [`PubSubEngine` class](https://github.com/apollographql/graphql-subscriptions/blob/master/src/pubsub-engine.ts). Recommended subclasses are listed in [PubSub implementations](#pubsub-implementations).

Apollo Server uses a **publish-subscribe** (**pub/sub**) model to track events that update active subscriptions. The [`graphql-subscriptions` library](https://github.com/apollographql/graphql-subscriptions) (included in every `apollo-server` package) provides the `PubSub` class to help you get started:

```js
const { PubSub } = require('apollo-server');

const pubsub = new PubSub();
```

A `PubSub` instance enables your server code to both `publish` events to a particular label and listen for events associated with a particular label.

### Publishing an event

You publish an event with the `publish` method of a `PubSub` instance:

```js
pubsub.publish('POST_CREATED', {
  postCreated: {
    author: 'Ali Baba',
    comment: 'Open sesame'
  }
});
```

* The first parameter is the name of the event label you're publishing to, as a string.
    * _You don't need to register a label name before publishing to it._
* The second parameter is the payload associated with the event.
    * _The payload's structure should match the structure of the associated subscription's return type._

When working with GraphQL subscriptions, you should `publish` an event whenever a subscription's return value changes. One of the most common causes of such a change is a mutation.

For example, let's say our GraphQL API supports a `createPost` mutation:

```graphql
type Mutation {
  createPost(author: String, comment: String): Post
}
```

A basic resolver for `createPost` might look like this:

```js{3-6}
const resolvers = {
  Mutation: {
    createPost(parent, args, context) {
      // Datastore logic lives in postController
      return postController.createPost(args);
    },
  },
  // ...other resolvers...
};
```

Before we persist the new post's details in our datastore, we can `publish` an event that _also_ includes those details:

```js
const resolvers = {
  Mutation: {
    createPost(parent, args, context) {
      pubsub.publish('POST_CREATED', { postCreated: args }); // highlight-line
      return postController.createPost(args);
    },
  },
  // ...other resolvers...
};
```

Next, we can listen for this event in our subscription's resolver.

### Listening for events

An [`AsyncIterable`](https://github.com/apollographql/graphql-subscriptions/blob/master/src/pubsub-async-iterator.ts) object listens for events that are associated with a particular label (or set of labels) and adds them to a queue for processing. You create an `AsyncIterable` by calling the `asyncIterator` method of `PubSub`:

```js
pubsub.asyncIterator(['POST_CREATED']);
```

You pass this method an array containing the names of all event labels that the `AsyncIterable` should listen for.

Every subscription resolver's `subscribe` function must return an `AsyncIterable` object. This brings us back to the code sample at the top of [Resolving a subscription](#resolving-a-subscription):

```js:title=index.js
const resolvers = {
  Subscription: {
    postCreated: {
      subscribe: () => pubsub.asyncIterator(['POST_CREATED']),
    },
  },
  // ...other resolvers...
};
```

With this `subscribe` function set, Apollo Server uses the payloads of `POST_CREATED` events to push updated field values for the `postCreated` subscription.

### Filtering events

Sometimes, a client should only receive updated subscription data if it meets certain criteria. To support this, you can call the `withFilter` helper function in your subscription's resolver.

#### Example

Let's say our server provides a `commentAdded` subscription, which should notify clients whenever a comment is added to a specified code repository. A client can execute a subscription that looks like this:

```graphql
subscription($repoName: String!){
  commentAdded(repoFullName: $repoName) {
    id
    content
  }
}
```

This presents a potential issue: our server probably [publishes a `COMMENT_ADDED` event](#publishing-an-event) whenever a comment is added to _any_ repository. This means that the `commentAdded` resolver executes for _every_ new comment, regardless of which repository it's added to. As a result, subscribing clients might receive data they don't want (or shouldn't even have access to).

To fix this, we can use the `withFilter` helper function to control updates on a per-subscription basis.

Here's an example resolver for `commentAdded` that uses the `withFilter` function:

```js{5-12}
const { withFilter } = require('apollo-server');

const resolvers = {
  Subscription: {
    commentAdded: {
      subscribe: withFilter(
        () => pubsub.asyncIterator('COMMENT_ADDED'),
        (payload, variables) => {
          // Only push an update if the comment is on
          // the correct repository for this operation
          return (payload.commentAdded.repository_name === variables.repoFullName);
        },
      ),
    }
  },
    // ...other resolvers...
};
```

The `withFilter` function takes two parameters:

* The first parameter is exactly the function you would use for `subscribe` if you _weren't_ applying a filter.
* The second parameter is a **filter function** that returns `true` if a subscription update _should_ be sent to a particular client, and `false` otherwise (`Promise<boolean>` is also allowed). This function takes two parameters of its own:
    * `payload` is the payload of the event that was published.
    * `variables` is an object containing all arguments the client provided when initiating their subscription.

Use `withFilter` to make sure clients get exactly the subscription updates they want (and are allowed to receive).


### Combined example

This example combines the snippets from the sections above:

<ExpansionPanel title="Click to expand">

```js:title=index.js
const typeDefs = gql`
  type Subscription {
    postCreated: Post
  }

  type Query {
    posts: [Post]
  }

  type Mutation {
    createPost(author: String, comment: String): Post
  }

  type Post {
    author: String
    comment: String
  }
`

const resolvers = {
  Subscription: {
    postCreated: {
      subscribe: () => pubsub.asyncIterator(['POST_CREATED']),
    },
  },
  Query: {
    posts(parent, args, context) {
      return postController.posts();
    },
  },
  Mutation: {
    addPost(parent, args, context) {
      pubsub.publish('POST_CREATED', { postCreated: args });
      return postController.addPost(args);
    },
  },
};
```

</ExpansionPanel>

## Initializing subscription context

When [initializing context](../data/resolvers/#the-context-argument) for a query or mutation operation, you usually extract HTTP headers and other request metadata from the `req` object provided to the `context` function:

```js{2-4}
const server = new ApolloServer({
  context: ({ req }) => ({
    authScope: getScope(req.headers.authorization)
  }),
  // ...other options...
}));
```

> Certain Apollo Server middleware integrations _don't_ use `req`. See [Middleware-specific context fields](../api/apollo-server/#middleware-specific-context-fields).

**For subscriptions,** you extract this metadata from the `connection` object instead. This object has the structure of [`ExecutionParams`](https://github.com/apollographql/subscriptions-transport-ws/blob/817e7de3a23db2b4d64eb846724175dba74025d0/src/server.ts#L24-L33) (which is different in structure to `req`).

Because all operation types use the same `context` initialization function, you should check which of `req` or `connection` is present for each incoming request:

```js
const server = new ApolloServer({
  context: ({ req, connection }) => {
    if (connection) { // Operation is a Subscription
      // Obtain connectionParams-provided token from connection.context
      const token = connection.context.authorization || "";
      return { token };
    } else { // Operation is a Query/Mutation
      // Obtain header-provided token from req.headers
      const token = req.headers.authorization || "";
      return { token };
    }
  },
});
```

This is especially important because metadata like auth tokens are sent differently depending on the transport.

## `onConnect` and `onDisconnect`

You can define functions that Apollo Server executes whenever a subscription request connects (`onConnect`) or disconnects (`onDisconnect`).

Defining an `onConnect` function provides the following benefits:

* You can reject a particular incoming connection by throwing an exception or returning `false` in `onConnect`.
    * This is especially useful for [authentication](#example-authentication-with-onconnect).
* The return value of `onConnect` is automatically added to the associated subscription operation's [context object](#initializing-subscription-context).

You provide these function definitions to the constructor of `ApolloServer`, like so:

```js
const server = new ApolloServer(
  subscriptions: {
    onConnect: (connectionParams, webSocket, context) => {
      console.log('Connected!')
    },
    onDisconnect: (webSocket, context) => {
      console.log('Disconnected!')
    },
  },
);
```

These functions are passed the following parameters:

<table class="field-table">
  <thead>
    <tr>
      <th>Name /<br/>Type</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

###### `connectionParams`

`Object`

</td>
<td>

**Passed to `onConnect` only.**

An object containing parameters included in the request, such as an [authentication token](#example-authentication-with-onconnect).

For details, see [Authenticate over WebSocket](https://www.apollographql.com/docs/react/data/subscriptions/#4-authenticate-over-websocket-optional) in the Apollo Client documentation.

</td>
</tr>

<tr>
<td>

###### `webSocket`

`WebSocket`
</td>
<td>

The connecting or disconnecting [`WebSocket`](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket).

</td>
</tr>

<tr>
<td>

###### `context`

`ConnectionContext`
</td>
<td>

Context object for the WebSocket connection. This is _not_ the `context` object for the associated subscription operation.

[See fields](https://github.com/apollographql/subscriptions-transport-ws/blob/master/src/server.ts#L35-L43)

</td>
</tr>

</tbody>
</table>

### Example: Authentication with `onConnect`

On the client, `SubscriptionsClient` supports adding token information to `connectionParams` ([example](https://www.apollographql.com/docs/react/advanced/subscriptions/#authentication-over-websocket)) that will be sent with the first WebSocket message. In the server, all GraphQL subscriptions are delayed until the connection has been fully authenticated and the `onConnect` callback returns a truthy value.

The `connectionParams` argument in the `onConnect` callback contains the information passed by the client and can be used to validate user credentials.
The GraphQL context can also be extended with the authenticated user data to enable fine grain authorization.

```js
const { ApolloServer } = require('apollo-server');
const { resolvers, typeDefs } = require('./schema');

const validateToken = authToken => {
  // ... validate token and return a Promise, rejects in case of an error
};

const findUser = authToken => {
  return tokenValidationResult => {
    // ... finds user by auth token and return a Promise, rejects in case of an error
  };
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
  subscriptions: {
    onConnect: (connectionParams, webSocket) => {
      if (connectionParams.authToken) {
        return validateToken(connectionParams.authToken)
          .then(findUser(connectionParams.authToken))
          .then(user => {
            return {
              currentUser: user,
            };
          });
      }

      throw new Error('Missing auth token!');
    },
  },
});

server.listen().then(({ url, subscriptionsUrl }) => {
  console.log(`🚀 Server ready at ${url}`);
  console.log(`🚀 Subscriptions ready at ${subscriptionsUrl}`);
});
```

The example above validates the user's token that is sent with the first initialization message on the transport, then it looks up the user and returns the user object as a Promise. The user object found will be available as `context.currentUser` in your GraphQL resolvers.

In case of an authentication error, the Promise will be rejected, which prevents the client's connection.


## Subscriptions with additional middleware

With an existing HTTP server (created with `createServer`), we can add subscriptions using the `installSubscriptionHandlers`. Additionally, the subscription-capable integrations export `PubSub` and other subscription functionality.

For example: with an Express server already running on port 4000 that accepts GraphQL HTTP connections (POST) we can expose the subscriptions:

```js
const http = require('http');
const { ApolloServer } = require('apollo-server-express');
const express = require('express');

const PORT = 4000;
const app = express();
const server = new ApolloServer({ typeDefs, resolvers });

server.applyMiddleware({app})

const httpServer = http.createServer(app);
server.installSubscriptionHandlers(httpServer); // highlight-line

// ⚠️ Pay attention to the fact that we are calling `listen` on the http server variable, and not on `app`.
httpServer.listen(PORT, () => {
  console.log(`🚀 Server ready at http://localhost:${PORT}${server.graphqlPath}`)
  console.log(`🚀 Subscriptions ready at ws://localhost:${PORT}${server.subscriptionsPath}`)
})
```



## `PubSub` implementations

> **Please note**: By default `graphql-subscriptions` exports an in-memory (`EventEmitter`) event system to re-run subscriptions. This is not suitable for running in a serious production app, because there is no way to share subscriptions and publishes across many running servers.
>
> We recommend using one of the external `PubSub` implementations listed below for production environments.

The Apollo Server implementation of `PubSub` can be replaced by another implementations of [PubSubEngine interface](https://github.com/apollographql/graphql-subscriptions/blob/master/src/pubsub-engine.ts). The community has created the following integrations:

- [Redis](https://github.com/davidyaha/graphql-redis-subscriptions)
- [Google PubSub](https://github.com/axelspringer/graphql-google-pubsub)
- [MQTT enabled broker](https://github.com/davidyaha/graphql-mqtt-subscriptions)
- [RabbitMQ](https://github.com/cdmbase/graphql-rabbitmq-subscriptions)
- [Kafka](https://github.com/ancashoria/graphql-kafka-subscriptions)
- [Postgres](https://github.com/GraphQLCollege/graphql-postgres-subscriptions)
- [Google Cloud Firestore](https://github.com/MrBoolean/graphql-firestore-subscriptions)
- [Add your implementation...](https://github.com/apollographql/apollo-server/pull/new/main)

You can implement a `PubSub` of your own, using the exported `PubSubEngine` interface from `apollo-server` or another integration. If you want to set up a GraphQL server using the `graphql-subscriptions` package (not recommended for production), follow [this guide](https://www.apollographql.com/docs/graphql-subscriptions/).
